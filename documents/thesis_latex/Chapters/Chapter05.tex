% Chapter 5

\chapter{Project Outcome} % Chapter title

\label{ch:outcome} 
% For referencing the chapter elsewhere, use \autoref{ch:outcome} 

%----------------------------------------------------------------------------------------

The project ended up with a web-based project management system.
The system consists of basic managing features which cover most common scenarios in PMT.
Besides that, the system also follows a set of MLS policies described in \autoref{ch:background:bell}.
This chapter includes an installation guide to setup the project from fresh; 
the system's user guide which describes its features and their usage demonstrations.
And at the end, I will discuss about my learning from the project's developing progress.

%----------------------------------------------------------------------------------------

\section{Installation Guide}
\label{ch:result:installation_guide}

\autoref{ch:implementation:technical_information} listed the technical requirements for this project.
In this guide, we will learn about the project's setup from scratch, step by step.

Assume that you already have a machine running CentOS 7 with these packages have already been installed: \emph{git, postgresql, nodejs with npm}.
I am using \emph{Digital Ocean} as VPS provider.
I create a \emph{Digital Ocean's droplet} with this specification: \emph{512MB Ram 20GB SSD Disk CentOS 7.1 x64}.
A postgresql database should be created and named as \emph{hotpot} whose owner is \emph{hotpot} and the password at your own choice.

First of all we need to clone the project's source code from GitHub using the command.
\begin{lstlisting}[breaklines=false,frame=lt]
$ git clone git@github.com:khangpn/hotpot.git
\end{lstlisting}

Next, we need to install all the project's dependencies by going into the project's root directory and execute \emph{npm} install command
\begin{lstlisting}[breaklines=false,frame=lt]
$/hotpot/ npm install
\end{lstlisting}
This command may take a while to install all required packages.

After checking the database accessibility, we need to configure its connection in \emph{config\/database.js}. 
Open that file by your favorite text editor, my choice is \emph{vim}. 
\begin{lstlisting}[breaklines=false,frame=lt]
$/hotpot/ vim config/database.js
\end{lstlisting}

Below is an example of the database configuration, if you named the database, its user and password are \emph{hotpot} and the database is running on local machine, then your configuration file should be similar to this.
\begin{lstlisting}[breaklines=false,frame=lt]
var settings = {                                                                                                                                                     
  development: { 
    database : "hotpot",
    username : "hotpot",
    password : "hotpot",
    options  : { 
      dialect : "postgresql",
      host     : "127.0.0.1"   
    }
  },
  production: { 
    database : "hotpot",
    username : "hotpot",
    password : "hotpot",
    options  : { 
      dialect : "postgresql",  
      host     : "127.0.0.1"   
    }
  }
};
  
module.exports = settings;
\end{lstlisting}

Next, lets open file \emph{setup} and change its \emph{NODE\_ENV} to \emph{development} or \emph{production} depending on your purpose.
\emph{Development} environemnt will print out the system's logs on our server and return errors' full stack trace to client, while  \emph{production} will omit it.
\begin{lstlisting}[breaklines=false,frame=lt]
// file hotpot/setup
NODE_ENV=development DEBUG=hotpot node bin/db-integration.js
\end{lstlisting}

Also edit file \emph{start} to change its \emph{NODE\_ENV}
\begin{lstlisting}[breaklines=false,frame=lt]
// file hotpot/start
NODE_ENV=development DEBUG=hotpot npm start
\end{lstlisting}
We can also add \emph{PORT} variable to the script to specify the project's running port. By default, it runs on port \emph{3000}
\begin{lstlisting}[breaklines=false,frame=lt]
// file hotpot/start
NODE_ENV=development PORT=4000 DEBUG=hotpot npm start
\end{lstlisting}

Next, we have to initialize the project's database schema using the \emph{setup} script.
\begin{lstlisting}[breaklines=false,frame=lt]
$/hotpot/ ./setup
\end{lstlisting}
This setup may take a while. And finally we can start the project using the \emph{start} script.
\begin{lstlisting}[breaklines=false,frame=lt]
$/hotpot/ ./start
\end{lstlisting}

%----------------------------------------------------------------------------------------

\section{User Guide}
\label{ch:result:user_guide}

used technologies. system requirement, test cases and their results to show how system works.

%----------------------------------------------------------------------------------------
\section{Learnings}

As working on the project, I have learned many new things.
First of all, technically, this is my second \emph{Nodejs} project.
So in this project, I deliberately chose it for study purpose.
After the project, I had an improving about \emph{Nodejs} and one of its most popular framework \emph{Expressjs}.
All of my experiences and learning about it are noted in \emph{diary} directory on GitHub repository which is listed in \autoref{ch:implementation:source_code_mangement}.
Those diaries are my daily reports of what I have done, the problems occurred on that day, and their solutions if available\dots

About programming experience, there is one advise which may be very useful when we have to due with unfamiliar issues of new technologies: always spend time for reading the technology's documents.
\marginpar{``Give me six hours to chop down a tree and I will spend the first four sharpening the axe'' -- Abraham Lincoln (1809-1865) }
Obviously, with the strong supports of huge technical communities these days, we can easily finish our jobs by searching for available solutions.
However, it doesn't help us to master the technology on our own \ie we don't understand it enough to handle other problems in the future.
Reading documentation will profit us in understand the technology's principles, from that we can study best practices in using it.
Consequently, it will improve our performance in using it.
On the other hand, spending time on learning a technology properly, we will also learn its owner's experience on programming and problems solving skills.
In another word, we can inherit his programming mindsets, design patterns which could be profitable in our future projects.
My suggestion is to put technology studying as a task in the project's tasks list, and assign a time span to it as an usual one.
The time span should be long enough for reading through the technology's documents, and not too long or it will become time consuming.
It took me two days to learn about \emph{Expressjs} enough for me to start working with it initially.
And it takes the same amount of time for me to studying using some crucial libraries such as \emph{Sequelizejs}, \emph{Promise}\dots
And on the working progress, I can learn more about their good practices.

Besides that, studying about MLS is a huge advantage to me.
Security is always a hot and essential topic, MLS is one of it.
Through the project, I learned about the MLS policies, and how they could be implemented in a system.
We have to design a blueprint of the system based on selected MLS model.
The blueprint consists of rules that \emph{subjects} and \emph{objects} of the system must be devoted to.
In the progress, we need to review it multiple times in multiple points of view to ensure that there is no exception.
Rather than that, again, there is no \emph{one master solution for all problems}, sometimes we have to make compromises.
In another word, for example, we have to make trade-off between performance and security.
The high secured system may be complicated and inflexible; however, flexible system with many \emph{trusted subjects/objects} could pose security leaks in the future.
So that, whenever we have to make a compromise, we have to acknowledge and keep in mind (or better, in note) its consequences to avoid in future work.

Planing is also an extensive skill.
Although, this project is my personal project, I learned a lot of time management.
In my own opinion, at the first try, we should assign a task with a small extension of time than we have evaluated.
We should not give a too tight time slot for very first tasks, there will be usually some modifications in features list and project requirements at the first stage of the project; and making early decisions very likely leads to changes.
As the progress goes on, the project is also getting stable.
The number of sudden changes or making decision will decrease remarkably.
Consequently, at this time, we can shorten the addition time extension, or just omit it.

